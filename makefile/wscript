#! /usr/bin/env python
# encoding: utf-8

# Note that this file is not needed for building the example with make
# The only purpose of this file is to ensure that the make works as intended

import os
import types

from waflib import Task

def configure(conf):
    # Check if make is installed on the system
    try:
        conf.find_program('make')
        conf.env.MAKE_INSTALLED = True
    except conf.errors.ConfigurationError as e:
        conf.env.MAKE_INSTALLED = False

def build(bld):

    # Call make with special arguments
    def invoke_make(task):

        args = []
        bld = task.generator.bld

        # Set the C compiler
        args += ['CC=' + bld.env.get_flat('CC')]
        # Set the C++ compiler
        args += ['CXX=' + bld.env.get_flat('CXX')]

        # Set the path for the dependencies
        sak_dir = os.path.join(bld.dependency_path('sak'),'src')
        args += ['SAK_DIR=' + sak_dir]
        fifi_dir = os.path.join(bld.dependency_path('fifi'),'src')
        args += ['FIFI_DIR=' + fifi_dir]
        kodo_dir = os.path.join(bld.dependency_path('kodo'),'src')
        args += ['KODO_DIR=' + fifi_dir]
        boost_dir = bld.dependency_path('boost')
        args += ['BOOST_DIR=' + boost_dir]

        # Get the current directory
        current_dir = task.generator.path.abspath()

        ret = bld.exec_command(['make'] + args, cwd=current_dir)

        if ret:
            bld.fatal('make returned %r' % ret)

        return ret

    # Build the example with make (only if make is installed)
    if bld.env.MAKE_INSTALLED:
        # Get the task generator
        bld(rule     = invoke_make,
            name     = 'sample_makefile',
            always   = True,
            source   = 'Makefile')


